package com.duapps.affair.demo.controller;import com.duapps.affair.demo.redLock.AquiredLockWorker;import com.duapps.affair.demo.redLock.RedisLocker;import com.duapps.affair.demo.redLock.RedissonConnector;import org.redisson.api.RLock;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.Random;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;/** * @Author he.zhou * @Date 2021-04-12 */@RestControllerpublic class RedLockController {    @Autowired    private RedissonConnector redissonConnector;    @RequestMapping(value = "/redlock/test")    public String testRedlock1() throws Exception {        CountDownLatch latch = new CountDownLatch(3);        for (int i = 0; i < 3; i++) {            new Thread(() -> {                test();                latch.countDown();            }).start();        }        latch.await();        return null;    }    private void test() {        RLock lock = redissonConnector.getClient().getLock("test");        boolean success = true;//            success = lock.tryLock(7000, 3000, TimeUnit.MILLISECONDS);        lock.lock();        if (success) {            try {                System.out.println(Thread.currentThread().getName() + "获取到锁");                try {                    Thread.sleep(5000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName() + "执行完");            } finally {                lock.unlock();            }        }    }//    @RequestMapping(value = "/redlock")//    public String testRedlock() throws Exception {////        CountDownLatch startSignal = new CountDownLatch(1);//        CountDownLatch doneSignal = new CountDownLatch(5);//        for (int i = 0; i < 5; ++i) { // create and start threads//            new Thread(new Worker(startSignal, doneSignal)).start();//        }//        startSignal.countDown(); // let all threads proceed//        doneSignal.await();//        System.out.println("All processors done. Shutdown connection");//        return "redlock";//    }////    class Worker implements Runnable {//        private final CountDownLatch startSignal;//        private final CountDownLatch doneSignal;////        Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {//            this.startSignal = startSignal;//            this.doneSignal = doneSignal;//        }////        public void run() {//            try {//                startSignal.await();//                distributedLocker.lock("test", new AquiredLockWorker<Object>() {////                    @Override//                    public Object invokeAfterLockAquire() {//                        doTask();//                        return null;//                    }////                });//            } catch (Exception e) {////            }//        }////        void doTask() {//            System.out.println(Thread.currentThread().getName() + " start");//            Random random = new Random();//            int _int = random.nextInt(200);//            System.out.println(Thread.currentThread().getName() + " sleep " + _int + "millis");//            try {//                Thread.sleep(_int);//            } catch (InterruptedException e) {//                e.printStackTrace();//            }//            System.out.println(Thread.currentThread().getName() + " end");//            doneSignal.countDown();//        }//    }}